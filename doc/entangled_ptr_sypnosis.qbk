[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]


[section The =entangled_ptr= class template]
[h2 Sypnosis]
``
  namespace boost{
      template <class T> class entangled_ptr{
      public:
          entangled_ptr();
          entangled_ptr(const entangled_ptr&);
          entangled_ptr(const entangled_ptr&&);
          template <class Y> entangled_ptr(const entangled_ptr<Y>&&);
          template <class Y> entangled_ptr(const entangled_ptr<Y>&);
          template <class Y> entangled_ptr(const proxy_ptr<Y>&);
          template <class Y> entangled_ptr(const shared_ptr<Y>&);
          template <class Y> entangled_ptr(const weak_ptr<Y>&);
      
          ~entangled_ptr();
          
          entangled_ptr& operator=(const entangled_ptr&);
          entangled_ptr& operator=(const entangled_ptr&&);
          template <class Y> entangled_ptr<Y>& operator=(const entangled_ptr<Y>&);
          template <class Y> entangled_ptr<Y>& operator=(const entangled_ptr<Y>&&);
          template <class Y> entangled_ptr<Y>& operator=(const proxy_ptr<Y>&);
          template <class Y> entangled_ptr<Y>& operator=(const shared_ptr<Y>&);
          template <class Y> entangled_ptr<Y>& operator=(const weak_ptr<Y>&);
      
          long use_count() const;
          bool expired() const;
          shared_ptr<T> lock() const;
          void reset();
          void swap(entangled_ptr&);
      }; // entangled_ptr class template
  } // namespace boost
``
[h2 Members]

[h3 expired]
Check whether it is possible to increment the use count. And, if this is
not the case, also destroy the object if it hasn't been destroyed already.

[endsect]

